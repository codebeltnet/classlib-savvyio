using Cuemon.Extensions.Collections.Generic;using System;using System.Collections.Generic;using System.Linq;using System.Reflection;using Cuemon;namespace Savvyio.Reflection{    /// <summary>    /// Provides a set of static methods and properties to manage and filter assemblies in the current application domain.    /// </summary>    public static class AssemblyContext    {        private static readonly Lazy<IReadOnlyList<Assembly>> AssemblyLoadFactory = new(() => AppDomain            .CurrentDomain            .GetAssemblies()            .Where(AssemblyFilterCallback)            .SelectMany(AssemblyDependenciesCallback)            .Distinct()            .Except(typeof(AssemblyContext).Assembly.Yield())            .ToList()            .AsReadOnly());        private static Func<Assembly, bool> _assemblyFilterCallback = DefaultAssemblyFilter;        private static Func<Assembly, IEnumerable<Assembly>> _assemblyDependenciesCallback = DefaultAssemblyDependencies;        private static Func<AssemblyName, bool> _assemblyDependenciesFilterCallback = DefaultAssemblyDependenciesFilter;        /// <summary>        /// Gets or sets the function delegate that filters assemblies from the current application domain.        /// </summary>        /// <value>The function delegate that filters assemblies from the current application domain.</value>        /// <remarks>The default implementation filters away assemblies that suggest being part of the .NET runtime themselves.</remarks>        /// <exception cref="ArgumentNullException">        /// <paramref name="value"/> cannot be null.        /// </exception>        public static Func<Assembly, bool> AssemblyFilterCallback        {            get => _assemblyFilterCallback;            set => _assemblyFilterCallback = value ?? throw new ArgumentNullException(nameof(value));        }        /// <summary>        /// Gets or sets the function delegate that recursively discover dependencies for an assembly in the current application domain.        /// </summary>        /// <value>The function delegate that recursively discover dependencies for an assembly in the current application domain.</value>        /// <exception cref="ArgumentNullException">        /// <paramref name="value"/> cannot be null.        /// </exception>        public static Func<Assembly, IEnumerable<Assembly>> AssemblyDependenciesCallback        {            get => _assemblyDependenciesCallback;            set => _assemblyDependenciesCallback = value ?? throw new ArgumentNullException(nameof(value));        }        /// <summary>        /// Gets or sets the function delegate that filters assembly dependencies from the current application domain.        /// </summary>        /// <value>The function delegate that filters assembly dependencies from the current application domain.</value>        /// <remarks>The default implementation filters away assembly dependencies that suggest being part of the .NET runtime themselves.</remarks>        /// <exception cref="ArgumentNullException">        /// <paramref name="value"/> cannot be null.        /// </exception>        public static Func<AssemblyName, bool> AssemblyDependenciesFilterCallback        {            get => _assemblyDependenciesFilterCallback;            set => _assemblyDependenciesFilterCallback = value ?? throw new ArgumentNullException(nameof(value));        }        /// <summary>        /// Gets the qualified assemblies from the current application domain.        /// </summary>        /// <value>The qualified assemblies from the current application domain.</value>        /// <remarks>This result of this property is coupled with <see cref="AssemblyFilterCallback"/> and <see cref="AssemblyDependenciesCallback"/>.</remarks>        public static IReadOnlyList<Assembly> CurrentDomainAssemblies => AssemblyLoadFactory.Value;        private static bool DefaultAssemblyFilter(Assembly assembly)        {            return assembly.FullName != null &&                   !assembly.FullName.StartsWith(nameof(System)) &&                   !assembly.FullName.StartsWith(nameof(Microsoft));        }        private static bool DefaultAssemblyDependenciesFilter(AssemblyName assemblyName)        {            return !assemblyName.FullName.StartsWith(nameof(System)) &&                   !assemblyName.FullName.StartsWith(nameof(Microsoft));        }        private static IEnumerable<Assembly> DefaultAssemblyDependencies(Assembly assembly)        {            var stack = new Stack<Assembly>();            var guard = new HashSet<string>();            yield return assembly;            stack.Push(assembly);            guard.Add(assembly.FullName);            while (stack.TryPop(out var assemblyToTraverse))            {                foreach (var assemblyName in assemblyToTraverse.GetReferencedAssemblies().Where(AssemblyDependenciesFilterCallback))                {                    if (!guard.Add(assemblyName.FullName)) { continue; }                    if (Patterns.TryInvoke(() => Assembly.Load(assemblyName), out var referencedAssembly) && referencedAssembly != null)                    {                        stack.Push(referencedAssembly);                        yield return referencedAssembly;                    }                }            }        }    }}